#!/usr/bin/env bash
#
# Generated with https://argbash.io
# ARG_OPTIONAL_BOOLEAN([update],[u],[update to latest release])
# ARG_OPTIONAL_BOOLEAN([debug],[d],[run with debug output])
# ARG_HELP([See https://github.com/yoosiba/mrh])
#
# modifed to pass args out

die() {
    local _ret=$2
    test -n "$_ret" || _ret=1
    test "$_PRINT_HELP" = yes && print_help >&2
    echo "$1" >&2
    exit ${_ret}
}

begins_with_short_option() {
    local first_option all_short_options='udh'
    first_option="${1:0:1}"
    test "$all_short_options" = "${all_short_options/$first_option/}" && return 1 || return 0
}

print_help() {
    printf '%s\n' "See https://github.com/yoosiba/mrh"
    printf 'Usage: %s [-u|--(no-)update] [-d|--(no-)debug] [-h|--help]\n' "$0"
    printf '\t%s\n' "-u, --update, --no-update: update to latest release (off by default)"
    printf '\t%s\n' "-d, --debug, --no-debug: run with debug output (off by default)"
    printf '\t%s\n' "-h, --help: Prints help"
}

parse_commandline() {
    local -n user_flags=$1
    shift

    local _arg_update="off"
    local _arg_debug="off"

    while test $# -gt 0; do
        _key="$1"
        case "$_key" in
        -u | --no-update | --update)
            _arg_update="on"
            test "${1:0:5}" = "--no-" && _arg_update="off"
            user_flags[UPDATE]=$_arg_update
            ;;
        -u*)
            _arg_update="on"
            _next="${_key##-u}"
            if test -n "$_next" -a "$_next" != "$_key"; then
                { begins_with_short_option "$_next" && shift && set -- "-u" "-${_next}" "$@"; } || die "The short option '$_key' can't be decomposed to ${_key:0:2} and -${_key:2}, because ${_key:0:2} doesn't accept value and '-${_key:2:1}' doesn't correspond to a short option."
            fi
            user_flags[UPDATE]=$_arg_update
            ;;
        -d | --no-debug | --debug)
            _arg_debug="on"
            test "${1:0:5}" = "--no-" && _arg_debug="off"
            user_flags[DEBUG]=$_arg_debug
            ;;
        -d*)
            _arg_debug="on"
            _next="${_key##-d}"
            if test -n "$_next" -a "$_next" != "$_key"; then
                { begins_with_short_option "$_next" && shift && set -- "-d" "-${_next}" "$@"; } || die "The short option '$_key' can't be decomposed to ${_key:0:2} and -${_key:2}, because ${_key:0:2} doesn't accept value and '-${_key:2:1}' doesn't correspond to a short option."
            fi
            user_flags[DEBUG]=$_arg_debug
            ;;
        -h | --help)
            print_help
            exit 0
            ;;
        -h*)
            print_help
            exit 0
            ;;
        *)
            _PRINT_HELP=yes die "FATAL ERROR: Got an unexpected argument '$1'" 1
            ;;
        esac
        shift
    done

    if [ "$_arg_debug" == "on" ]; then
        echo "config:"
        for key in "${!user_flags[@]}"; do
            echo " - $key=${user_flags[$key]}"
        done
    fi

}

# OTHER STUFF GENERATED BY Argbash

### END OF CODE GENERATED BY Argbash (sortof) ### ])
# [ <-- needed because of Argbash

# ] <-- needed because of Argbash
